

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mlquantify.methods.aggregative &mdash; mlquantify 0.0.11.6 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=bad190ef"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="mlquantify.methods.aggregative.ThreholdOptm" href="ThreholdOptm/index.html" />
    <link rel="prev" title="mlquantify.methods" href="../index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            mlquantify
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../../index.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../index.html">mlquantify</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../../index.html#submodules">Submodules</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../../base/index.html">mlquantify.base</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../classification/index.html">mlquantify.classification</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../evaluation/index.html">mlquantify.evaluation</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="../index.html">mlquantify.methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../model_selection/index.html">mlquantify.model_selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../plots/index.html">mlquantify.plots</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../utils/index.html">mlquantify.utils</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../index.html#attributes">Attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../index.html#classes">Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../index.html#functions">Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../index.html#package-contents">Package Contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">mlquantify</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">API Reference</a></li>
          <li class="breadcrumb-item"><a href="../../index.html">mlquantify</a></li>
          <li class="breadcrumb-item"><a href="../index.html">mlquantify.methods</a></li>
      <li class="breadcrumb-item active">mlquantify.methods.aggregative</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/autoapi/mlquantify/methods/aggregative/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-mlquantify.methods.aggregative">
<span id="mlquantify-methods-aggregative"></span><h1>mlquantify.methods.aggregative<a class="headerlink" href="#module-mlquantify.methods.aggregative" title="Link to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="ThreholdOptm/index.html">mlquantify.methods.aggregative.ThreholdOptm</a></li>
<li class="toctree-l1"><a class="reference internal" href="cc/index.html">mlquantify.methods.aggregative.cc</a></li>
<li class="toctree-l1"><a class="reference internal" href="emq/index.html">mlquantify.methods.aggregative.emq</a></li>
<li class="toctree-l1"><a class="reference internal" href="fm/index.html">mlquantify.methods.aggregative.fm</a></li>
<li class="toctree-l1"><a class="reference internal" href="gac/index.html">mlquantify.methods.aggregative.gac</a></li>
<li class="toctree-l1"><a class="reference internal" href="gpac/index.html">mlquantify.methods.aggregative.gpac</a></li>
<li class="toctree-l1"><a class="reference internal" href="mixtureModels/index.html">mlquantify.methods.aggregative.mixtureModels</a></li>
<li class="toctree-l1"><a class="reference internal" href="pcc/index.html">mlquantify.methods.aggregative.pcc</a></li>
<li class="toctree-l1"><a class="reference internal" href="pwk/index.html">mlquantify.methods.aggregative.pwk</a></li>
</ul>
</div>
</section>
<section id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Link to this heading"></a></h2>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.ACC" title="mlquantify.methods.aggregative.ACC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ACC</span></code></a></p></td>
<td><p>Adjusted Classify and Count or Adjusted Count. Is a</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.MAX" title="mlquantify.methods.aggregative.MAX"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MAX</span></code></a></p></td>
<td><p>Threshold MAX. This method tries to use the</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.X_method" title="mlquantify.methods.aggregative.X_method"><code class="xref py py-obj docutils literal notranslate"><span class="pre">X_method</span></code></a></p></td>
<td><p>Threshold X. This method tries to</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.T50" title="mlquantify.methods.aggregative.T50"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T50</span></code></a></p></td>
<td><p>Threshold 50. This method tries to</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.MS" title="mlquantify.methods.aggregative.MS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MS</span></code></a></p></td>
<td><p>Median Sweep. This method uses an</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.MS2" title="mlquantify.methods.aggregative.MS2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MS2</span></code></a></p></td>
<td><p>Median Sweep 2. It relies on the same</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.PACC" title="mlquantify.methods.aggregative.PACC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PACC</span></code></a></p></td>
<td><p>Probabilistic Adjusted Classify and Count.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.HDy" title="mlquantify.methods.aggregative.HDy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HDy</span></code></a></p></td>
<td><p>Hellinger Distance Minimization. The method</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.DyS" title="mlquantify.methods.aggregative.DyS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DyS</span></code></a></p></td>
<td><p>Distribution y-Similarity framework. Is a</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.SORD" title="mlquantify.methods.aggregative.SORD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SORD</span></code></a></p></td>
<td><p>Sample Ordinal Distance. Is a method</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.SMM" title="mlquantify.methods.aggregative.SMM"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SMM</span></code></a></p></td>
<td><p>Sample Mean Matching. The method is</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.DySsyn" title="mlquantify.methods.aggregative.DySsyn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DySsyn</span></code></a></p></td>
<td><p>Synthetic Distribution y-Similarity. This method works the</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.CC" title="mlquantify.methods.aggregative.CC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CC</span></code></a></p></td>
<td><p>Classify and Count. The simplest quantification method</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.PCC" title="mlquantify.methods.aggregative.PCC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PCC</span></code></a></p></td>
<td><p>Probabilistic Classify and Count. This method</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.GAC" title="mlquantify.methods.aggregative.GAC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GAC</span></code></a></p></td>
<td><p>Generalized Adjusted Count. It applies a</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.GPAC" title="mlquantify.methods.aggregative.GPAC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GPAC</span></code></a></p></td>
<td><p>Generalized Probabilistic Adjusted Count. Like</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.FM" title="mlquantify.methods.aggregative.FM"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FM</span></code></a></p></td>
<td><p>The Friedman Method. Similar to GPAC,</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.EMQ" title="mlquantify.methods.aggregative.EMQ"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EMQ</span></code></a></p></td>
<td><p>Expectation Maximisation Quantifier. It is a method that</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.methods.aggregative.PWK" title="mlquantify.methods.aggregative.PWK"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PWK</span></code></a></p></td>
<td><p>Nearest-Neighbor based Quantification. This method</p></td>
</tr>
</tbody>
</table>
</section>
<section id="package-contents">
<h2>Package Contents<a class="headerlink" href="#package-contents" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.ACC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">ACC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.ACC" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ThreholdOptm/_ThreholdOptimization/index.html#mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization" title="mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization</span></code></a></p>
<p>Adjusted Classify and Count or Adjusted Count. Is a
base method for the threhold methods.</p>
<blockquote>
<div><p>As described on the Threshold base class, this method</p>
</div></blockquote>
<p>estimate the true positive and false positive rates from
the training data and utilize them to adjust the output
of the CC method.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.ACC.threshold">
<span class="sig-name descname"><span class="pre">threshold</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.ACC.threshold" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.ACC.best_tprfpr">
<span class="sig-name descname"><span class="pre">best_tprfpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.ACC.best_tprfpr" title="Link to this definition"></a></dt>
<dd><p>Abstract method for determining the best TPR and FPR to use in the equation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.MAX">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">MAX</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.MAX" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ThreholdOptm/_ThreholdOptimization/index.html#mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization" title="mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization</span></code></a></p>
<p>Threshold MAX. This method tries to use the
threshold where it maximizes the difference between
tpr and fpr to use in the denominator of the equation.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.MAX.best_tprfpr">
<span class="sig-name descname"><span class="pre">best_tprfpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.MAX.best_tprfpr" title="Link to this definition"></a></dt>
<dd><p>Abstract method for determining the best TPR and FPR to use in the equation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.X_method">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">X_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.X_method" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ThreholdOptm/_ThreholdOptimization/index.html#mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization" title="mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization</span></code></a></p>
<p>Threshold X. This method tries to
use the threshold where fpr = 1 - tpr</p>
<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.X_method.best_tprfpr">
<span class="sig-name descname"><span class="pre">best_tprfpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.X_method.best_tprfpr" title="Link to this definition"></a></dt>
<dd><p>Abstract method for determining the best TPR and FPR to use in the equation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.T50">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">T50</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.T50" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ThreholdOptm/_ThreholdOptimization/index.html#mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization" title="mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization</span></code></a></p>
<p>Threshold 50. This method tries to
use the threshold where tpr = 0.5.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.T50.best_tprfpr">
<span class="sig-name descname"><span class="pre">best_tprfpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.T50.best_tprfpr" title="Link to this definition"></a></dt>
<dd><p>Abstract method for determining the best TPR and FPR to use in the equation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.MS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">MS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.MS" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ThreholdOptm/_ThreholdOptimization/index.html#mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization" title="mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization</span></code></a></p>
<p>Median Sweep. This method uses an
ensemble of such threshold-based methods and
takes the median prediction.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.MS.threshold">
<span class="sig-name descname"><span class="pre">threshold</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.MS.threshold" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.MS.best_tprfpr">
<span class="sig-name descname"><span class="pre">best_tprfpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.MS.best_tprfpr" title="Link to this definition"></a></dt>
<dd><p>Abstract method for determining the best TPR and FPR to use in the equation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.MS2">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">MS2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.MS2" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ThreholdOptm/_ThreholdOptimization/index.html#mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization" title="mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization</span></code></a></p>
<p>Median Sweep 2. It relies on the same
strategy of the Median Sweep, but compute
the median only for cases in which
tpr -fpr &gt; 0.25</p>
<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.MS2.best_tprfpr">
<span class="sig-name descname"><span class="pre">best_tprfpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.MS2.best_tprfpr" title="Link to this definition"></a></dt>
<dd><p>Abstract method for determining the best TPR and FPR to use in the equation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.PACC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">PACC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.PACC" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ThreholdOptm/_ThreholdOptimization/index.html#mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization" title="mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization</span></code></a></p>
<p>Probabilistic Adjusted Classify and Count.
This method adapts the AC approach by using average
classconditional confidences from a probabilistic
classifier instead of true positive and false positive rates.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.PACC.threshold">
<span class="sig-name descname"><span class="pre">threshold</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.PACC.threshold" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.PACC._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.PACC._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.PACC.best_tprfpr">
<span class="sig-name descname"><span class="pre">best_tprfpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.PACC.best_tprfpr" title="Link to this definition"></a></dt>
<dd><p>Abstract method for determining the best TPR and FPR to use in the equation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.HDy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">HDy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.HDy" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="mixtureModels/_MixtureModel/index.html#mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel" title="mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel</span></code></a></p>
<p>Hellinger Distance Minimization. The method
is based on computing the hellinger distance of
two distributions, test distribution and the mixture
of the positive and negative distribution of the train.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.HDy._compute_prevalence">
<span class="sig-name descname"><span class="pre">_compute_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.HDy._compute_prevalence" title="Link to this definition"></a></dt>
<dd><p>Abstract method for computing the prevalence using the test scores</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.HDy.best_distance">
<span class="sig-name descname"><span class="pre">best_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_test</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.HDy.best_distance" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.HDy.GetMinDistancesHDy">
<span class="sig-name descname"><span class="pre">GetMinDistancesHDy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.HDy.GetMinDistancesHDy" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DyS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">DyS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'topsoe'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.DyS" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="mixtureModels/_MixtureModel/index.html#mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel" title="mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel</span></code></a></p>
<p>Distribution y-Similarity framework. Is a
method that generalises the HDy approach by
considering the dissimilarity function DS as
a parameter of the model</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DyS.bins_size">
<span class="sig-name descname"><span class="pre">bins_size</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.DyS.bins_size" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DyS.measure">
<span class="sig-name descname"><span class="pre">measure</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.DyS.measure" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DyS.prevs">
<span class="sig-name descname"><span class="pre">prevs</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.methods.aggregative.DyS.prevs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DyS._compute_prevalence">
<span class="sig-name descname"><span class="pre">_compute_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.DyS._compute_prevalence" title="Link to this definition"></a></dt>
<dd><p>Abstract method for computing the prevalence using the test scores</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DyS.best_distance">
<span class="sig-name descname"><span class="pre">best_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_test</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.DyS.best_distance" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DyS.GetMinDistancesDyS">
<span class="sig-name descname"><span class="pre">GetMinDistancesDyS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.DyS.GetMinDistancesDyS" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.SORD">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">SORD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.SORD" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="mixtureModels/_MixtureModel/index.html#mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel" title="mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel</span></code></a></p>
<p>Sample Ordinal Distance. Is a method
that does not rely on distributions, but
estimates the prevalence of the positive
class in a test dataset by calculating and
minimizing a sample ordinal distance measure
between the test scores and known positive
and negative scores.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.SORD.best_distance_index">
<span class="sig-name descname"><span class="pre">best_distance_index</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.methods.aggregative.SORD.best_distance_index" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.SORD._compute_prevalence">
<span class="sig-name descname"><span class="pre">_compute_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.SORD._compute_prevalence" title="Link to this definition"></a></dt>
<dd><p>Abstract method for computing the prevalence using the test scores</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.SORD._calculate_distances">
<span class="sig-name descname"><span class="pre">_calculate_distances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.SORD._calculate_distances" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.SMM">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">SMM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.SMM" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="mixtureModels/_MixtureModel/index.html#mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel" title="mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel</span></code></a></p>
<p>Sample Mean Matching. The method is
a member of the DyS framework that uses
simple means to represent the score
distribution for positive, negative
and unlabelled scores.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.SMM._compute_prevalence">
<span class="sig-name descname"><span class="pre">_compute_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.SMM._compute_prevalence" title="Link to this definition"></a></dt>
<dd><p>Abstract method for computing the prevalence using the test scores</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DySsyn">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">DySsyn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'topsoe'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">merge_factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_train</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.DySsyn" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="mixtureModels/_MixtureModel/index.html#mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel" title="mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel</span></code></a></p>
<p>Synthetic Distribution y-Similarity. This method works the
same as DyS method, but istead of using the train scores, it
generates them via MoSS (Model for Score Simulation) which
generate a spectrum of score distributions from highly separated
scores to fully mixed scores.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DySsyn.bins_size">
<span class="sig-name descname"><span class="pre">bins_size</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.DySsyn.bins_size" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DySsyn.merge_factor">
<span class="sig-name descname"><span class="pre">merge_factor</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.DySsyn.merge_factor" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DySsyn.alpha_train">
<span class="sig-name descname"><span class="pre">alpha_train</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.DySsyn.alpha_train" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DySsyn.n">
<span class="sig-name descname"><span class="pre">n</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.DySsyn.n" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DySsyn.measure">
<span class="sig-name descname"><span class="pre">measure</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.DySsyn.measure" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DySsyn.m">
<span class="sig-name descname"><span class="pre">m</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.methods.aggregative.DySsyn.m" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DySsyn._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.DySsyn._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DySsyn._compute_prevalence">
<span class="sig-name descname"><span class="pre">_compute_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.DySsyn._compute_prevalence" title="Link to this definition"></a></dt>
<dd><p>Abstract method for computing the prevalence using the test scores</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DySsyn.best_distance">
<span class="sig-name descname"><span class="pre">best_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.DySsyn.best_distance" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.DySsyn.GetMinDistancesDySsyn">
<span class="sig-name descname"><span class="pre">GetMinDistancesDySsyn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.DySsyn.GetMinDistancesDySsyn" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.CC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">CC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.CC" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="../../base/index.html#mlquantify.base.AggregativeQuantifier" title="mlquantify.base.AggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.AggregativeQuantifier</span></code></a></p>
<p>Classify and Count. The simplest quantification method
involves classifying each instance and then counting the
number of instances assigned to each class to estimate
the class prevalence.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.CC.learner">
<span class="sig-name descname"><span class="pre">learner</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.CC.learner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.CC._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.CC._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.CC._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.CC._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.PCC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">PCC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.PCC" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="../../base/index.html#mlquantify.base.AggregativeQuantifier" title="mlquantify.base.AggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.AggregativeQuantifier</span></code></a></p>
<p>Probabilistic Classify and Count. This method
takes the probabilistic predictions and takes the
mean of them for each class.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.PCC.learner">
<span class="sig-name descname"><span class="pre">learner</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.PCC.learner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.PCC._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.PCC._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.PCC._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.PCC._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GAC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">GAC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.GAC" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="../../base/index.html#mlquantify.base.AggregativeQuantifier" title="mlquantify.base.AggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.AggregativeQuantifier</span></code></a></p>
<p>Generalized Adjusted Count. It applies a
classifier to build a system of linear equations,
and solve it via constrained least-squares regression.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GAC.learner">
<span class="sig-name descname"><span class="pre">learner</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.GAC.learner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GAC.cond_prob_matrix">
<span class="sig-name descname"><span class="pre">cond_prob_matrix</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.methods.aggregative.GAC.cond_prob_matrix" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GAC.train_size">
<span class="sig-name descname"><span class="pre">train_size</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.GAC.train_size" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GAC.random_state">
<span class="sig-name descname"><span class="pre">random_state</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.GAC.random_state" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GAC._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.GAC._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GAC._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.GAC._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GAC.get_cond_prob_matrix">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_cond_prob_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_labels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.GAC.get_cond_prob_matrix" title="Link to this definition"></a></dt>
<dd><p>Estimate the conditional probability matrix P(yi|yj)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GAC.solve_adjustment">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solve_adjustment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cond_prob_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predicted_prevalences</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.GAC.solve_adjustment" title="Link to this definition"></a></dt>
<dd><p>Solve the linear system Ax = B with A=cond_prob_matrix and B=predicted_prevalences</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GPAC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">GPAC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.GPAC" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="../../base/index.html#mlquantify.base.AggregativeQuantifier" title="mlquantify.base.AggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.AggregativeQuantifier</span></code></a></p>
<p>Generalized Probabilistic Adjusted Count. Like
GAC, it also build a system of linear equations, but
utilize the confidence scores from probabilistic
classifiers as in the PAC method.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GPAC.learner">
<span class="sig-name descname"><span class="pre">learner</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.GPAC.learner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GPAC.cond_prob_matrix">
<span class="sig-name descname"><span class="pre">cond_prob_matrix</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.methods.aggregative.GPAC.cond_prob_matrix" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GPAC.train_size">
<span class="sig-name descname"><span class="pre">train_size</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.GPAC.train_size" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GPAC.random_state">
<span class="sig-name descname"><span class="pre">random_state</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.GPAC.random_state" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GPAC._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.GPAC._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GPAC._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.GPAC._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.GPAC.get_cond_prob_matrix">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_cond_prob_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_labels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_pred</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.GPAC.get_cond_prob_matrix" title="Link to this definition"></a></dt>
<dd><p>Estimate the matrix where entry (i,j) is the estimate of P(yi|yj)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.FM">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">FM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.FM" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="../../base/index.html#mlquantify.base.AggregativeQuantifier" title="mlquantify.base.AggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.AggregativeQuantifier</span></code></a></p>
<p>The Friedman Method. Similar to GPAC,
but instead of averaging the confidence scores
from probabilistic classifiers, it uses the proportion
of confidence scores that are higher or lower than the
expected class frequencies found in the training data.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.FM.learner">
<span class="sig-name descname"><span class="pre">learner</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.FM.learner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.FM.CM">
<span class="sig-name descname"><span class="pre">CM</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.methods.aggregative.FM.CM" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.FM._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.FM._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.FM._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.FM._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.EMQ">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">EMQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.EMQ" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="../../base/index.html#mlquantify.base.AggregativeQuantifier" title="mlquantify.base.AggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.AggregativeQuantifier</span></code></a></p>
<p>Expectation Maximisation Quantifier. It is a method that
ajust the priors and posteriors probabilities of a learner</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.EMQ.MAX_ITER">
<span class="sig-name descname"><span class="pre">MAX_ITER</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1000</span></em><a class="headerlink" href="#mlquantify.methods.aggregative.EMQ.MAX_ITER" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.EMQ.EPSILON">
<span class="sig-name descname"><span class="pre">EPSILON</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-06</span></em><a class="headerlink" href="#mlquantify.methods.aggregative.EMQ.EPSILON" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.EMQ.learner">
<span class="sig-name descname"><span class="pre">learner</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.EMQ.learner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.EMQ.priors">
<span class="sig-name descname"><span class="pre">priors</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.methods.aggregative.EMQ.priors" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.EMQ._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.EMQ._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.EMQ._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.EMQ._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.EMQ.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">EPSILON</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">MAX_ITER</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.EMQ.predict_proba" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.EMQ.EM">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">EM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">priors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">posteriors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">EPSILON</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">MAX_ITER</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.EMQ.EM" title="Link to this definition"></a></dt>
<dd><p>Expectaion Maximization function, it iterates several times
and At each iteration step, both the a posteriori and the a
priori probabilities are reestimated sequentially for each new
observation and each class. The iterative procedure proceeds
until the convergence of the estimated probabilities.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>priors (array-like): priors probabilites of the train.
posteriors (array-like): posteriors probabiblities of the test.
epsilon (float): value that helps to indify the convergence.
max_iter (int): max number of iterations.</p>
</dd>
<dt>Returns:</dt><dd><p>the predicted prevalence and the ajusted posteriors.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.PWK">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.methods.aggregative.</span></span><span class="sig-name descname"><span class="pre">PWK</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.PWK" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="../../base/index.html#mlquantify.base.AggregativeQuantifier" title="mlquantify.base.AggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.AggregativeQuantifier</span></code></a></p>
<p>Nearest-Neighbor based Quantification. This method
is based on nearest-neighbor based classification to the
setting of quantification. In this k-NN approach, it applies
a weighting scheme which applies less weight on neighbors
from the majority class.
Must be used with PWKCLF to work as expected.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.PWK.learner">
<span class="sig-name descname"><span class="pre">learner</span></span><a class="headerlink" href="#mlquantify.methods.aggregative.PWK.learner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.PWK._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.methods.aggregative.PWK._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.methods.aggregative.PWK._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.methods.aggregative.PWK._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../index.html" class="btn btn-neutral float-left" title="mlquantify.methods" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ThreholdOptm/index.html" class="btn btn-neutral float-right" title="mlquantify.methods.aggregative.ThreholdOptm" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Luiz Fernando Luth Junior.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>