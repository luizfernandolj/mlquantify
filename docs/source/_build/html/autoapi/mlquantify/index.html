

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mlquantify &mdash; mlquantify 0.0.11.6 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=bad190ef"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="mlquantify.base" href="base/index.html" />
    <link rel="prev" title="API Reference" href="../index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            mlquantify
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">mlquantify</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#submodules">Submodules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="base/index.html">mlquantify.base</a></li>
<li class="toctree-l4"><a class="reference internal" href="classification/index.html">mlquantify.classification</a></li>
<li class="toctree-l4"><a class="reference internal" href="evaluation/index.html">mlquantify.evaluation</a></li>
<li class="toctree-l4"><a class="reference internal" href="methods/index.html">mlquantify.methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="model_selection/index.html">mlquantify.model_selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="plots/index.html">mlquantify.plots</a></li>
<li class="toctree-l4"><a class="reference internal" href="utils/index.html">mlquantify.utils</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#attributes">Attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#package-contents">Package Contents</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.PWKCLF"><code class="docutils literal notranslate"><span class="pre">PWKCLF</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.absolute_error"><code class="docutils literal notranslate"><span class="pre">absolute_error()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.kullback_leibler_divergence"><code class="docutils literal notranslate"><span class="pre">kullback_leibler_divergence()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.normalized_kullback_leibler_divergence"><code class="docutils literal notranslate"><span class="pre">normalized_kullback_leibler_divergence()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.relative_absolute_error"><code class="docutils literal notranslate"><span class="pre">relative_absolute_error()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.normalized_absolute_error"><code class="docutils literal notranslate"><span class="pre">normalized_absolute_error()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.bias"><code class="docutils literal notranslate"><span class="pre">bias()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.normalized_relative_absolute_error"><code class="docutils literal notranslate"><span class="pre">normalized_relative_absolute_error()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.squared_error"><code class="docutils literal notranslate"><span class="pre">squared_error()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.mean_squared_error"><code class="docutils literal notranslate"><span class="pre">mean_squared_error()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.MEASURES"><code class="docutils literal notranslate"><span class="pre">MEASURES</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.get_measure"><code class="docutils literal notranslate"><span class="pre">get_measure()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.APP"><code class="docutils literal notranslate"><span class="pre">APP</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.NPP"><code class="docutils literal notranslate"><span class="pre">NPP</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.AGGREGATIVE"><code class="docutils literal notranslate"><span class="pre">AGGREGATIVE</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.NON_AGGREGATIVE"><code class="docutils literal notranslate"><span class="pre">NON_AGGREGATIVE</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.META"><code class="docutils literal notranslate"><span class="pre">META</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.METHODS"><code class="docutils literal notranslate"><span class="pre">METHODS</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.get_method"><code class="docutils literal notranslate"><span class="pre">get_method()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.CC"><code class="docutils literal notranslate"><span class="pre">CC</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.PCC"><code class="docutils literal notranslate"><span class="pre">PCC</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.GAC"><code class="docutils literal notranslate"><span class="pre">GAC</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.GPAC"><code class="docutils literal notranslate"><span class="pre">GPAC</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.FM"><code class="docutils literal notranslate"><span class="pre">FM</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.EMQ"><code class="docutils literal notranslate"><span class="pre">EMQ</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.PWK"><code class="docutils literal notranslate"><span class="pre">PWK</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.ACC"><code class="docutils literal notranslate"><span class="pre">ACC</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.MAX"><code class="docutils literal notranslate"><span class="pre">MAX</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.X_method"><code class="docutils literal notranslate"><span class="pre">X_method</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.T50"><code class="docutils literal notranslate"><span class="pre">T50</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.MS"><code class="docutils literal notranslate"><span class="pre">MS</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.MS2"><code class="docutils literal notranslate"><span class="pre">MS2</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.PACC"><code class="docutils literal notranslate"><span class="pre">PACC</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.HDy"><code class="docutils literal notranslate"><span class="pre">HDy</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.DyS"><code class="docutils literal notranslate"><span class="pre">DyS</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.SORD"><code class="docutils literal notranslate"><span class="pre">SORD</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.SMM"><code class="docutils literal notranslate"><span class="pre">SMM</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.DySsyn"><code class="docutils literal notranslate"><span class="pre">DySsyn</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.HDx"><code class="docutils literal notranslate"><span class="pre">HDx</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.Ensemble"><code class="docutils literal notranslate"><span class="pre">Ensemble</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.normalize_prevalence"><code class="docutils literal notranslate"><span class="pre">normalize_prevalence()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.parallel"><code class="docutils literal notranslate"><span class="pre">parallel()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.get_real_prev"><code class="docutils literal notranslate"><span class="pre">get_real_prev()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.make_prevs"><code class="docutils literal notranslate"><span class="pre">make_prevs()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.generate_artificial_indexes"><code class="docutils literal notranslate"><span class="pre">generate_artificial_indexes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.round_protocol_df"><code class="docutils literal notranslate"><span class="pre">round_protocol_df()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.convert_columns_to_arrays"><code class="docutils literal notranslate"><span class="pre">convert_columns_to_arrays()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.load_quantifier"><code class="docutils literal notranslate"><span class="pre">load_quantifier()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.getHist"><code class="docutils literal notranslate"><span class="pre">getHist()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.sqEuclidean"><code class="docutils literal notranslate"><span class="pre">sqEuclidean()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.probsymm"><code class="docutils literal notranslate"><span class="pre">probsymm()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.hellinger"><code class="docutils literal notranslate"><span class="pre">hellinger()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.topsoe"><code class="docutils literal notranslate"><span class="pre">topsoe()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.ternary_search"><code class="docutils literal notranslate"><span class="pre">ternary_search()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.compute_table"><code class="docutils literal notranslate"><span class="pre">compute_table()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.compute_tpr"><code class="docutils literal notranslate"><span class="pre">compute_tpr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.compute_fpr"><code class="docutils literal notranslate"><span class="pre">compute_fpr()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.adjust_threshold"><code class="docutils literal notranslate"><span class="pre">adjust_threshold()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.get_scores"><code class="docutils literal notranslate"><span class="pre">get_scores()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.MoSS"><code class="docutils literal notranslate"><span class="pre">MoSS()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.protocol_boxplot"><code class="docutils literal notranslate"><span class="pre">protocol_boxplot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.protocol_lineplot"><code class="docutils literal notranslate"><span class="pre">protocol_lineplot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.class_distribution_plot"><code class="docutils literal notranslate"><span class="pre">class_distribution_plot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#mlquantify.GridSearchQ"><code class="docutils literal notranslate"><span class="pre">GridSearchQ</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">mlquantify</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API Reference</a></li>
      <li class="breadcrumb-item active">mlquantify</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/autoapi/mlquantify/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-mlquantify">
<span id="mlquantify"></span><h1>mlquantify<a class="headerlink" href="#module-mlquantify" title="Link to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="base/index.html">mlquantify.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="classification/index.html">mlquantify.classification</a></li>
<li class="toctree-l1"><a class="reference internal" href="evaluation/index.html">mlquantify.evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="methods/index.html">mlquantify.methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="model_selection/index.html">mlquantify.model_selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="plots/index.html">mlquantify.plots</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils/index.html">mlquantify.utils</a></li>
</ul>
</div>
</section>
<section id="attributes">
<h2>Attributes<a class="headerlink" href="#attributes" title="Link to this heading"></a></h2>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.MEASURES" title="mlquantify.MEASURES"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MEASURES</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.AGGREGATIVE" title="mlquantify.AGGREGATIVE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AGGREGATIVE</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.NON_AGGREGATIVE" title="mlquantify.NON_AGGREGATIVE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NON_AGGREGATIVE</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.META" title="mlquantify.META"><code class="xref py py-obj docutils literal notranslate"><span class="pre">META</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.METHODS" title="mlquantify.METHODS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">METHODS</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</section>
<section id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Link to this heading"></a></h2>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.PWKCLF" title="mlquantify.PWKCLF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PWKCLF</span></code></a></p></td>
<td><p>Learner based on k-Nearest Neighborst (KNN) to use on the method PWK,</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.APP" title="mlquantify.APP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">APP</span></code></a></p></td>
<td><p>Artificial Prevalence Protocol. It splits a test into several</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.NPP" title="mlquantify.NPP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NPP</span></code></a></p></td>
<td><p>Base class for implementing different quantification protocols.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.CC" title="mlquantify.CC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CC</span></code></a></p></td>
<td><p>Classify and Count. The simplest quantification method</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.PCC" title="mlquantify.PCC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PCC</span></code></a></p></td>
<td><p>Probabilistic Classify and Count. This method</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.GAC" title="mlquantify.GAC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GAC</span></code></a></p></td>
<td><p>Generalized Adjusted Count. It applies a</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.GPAC" title="mlquantify.GPAC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GPAC</span></code></a></p></td>
<td><p>Generalized Probabilistic Adjusted Count. Like</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.FM" title="mlquantify.FM"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FM</span></code></a></p></td>
<td><p>The Friedman Method. Similar to GPAC,</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.EMQ" title="mlquantify.EMQ"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EMQ</span></code></a></p></td>
<td><p>Expectation Maximisation Quantifier. It is a method that</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.PWK" title="mlquantify.PWK"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PWK</span></code></a></p></td>
<td><p>Nearest-Neighbor based Quantification. This method</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.ACC" title="mlquantify.ACC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ACC</span></code></a></p></td>
<td><p>Adjusted Classify and Count or Adjusted Count. Is a</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.MAX" title="mlquantify.MAX"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MAX</span></code></a></p></td>
<td><p>Threshold MAX. This method tries to use the</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.X_method" title="mlquantify.X_method"><code class="xref py py-obj docutils literal notranslate"><span class="pre">X_method</span></code></a></p></td>
<td><p>Threshold X. This method tries to</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.T50" title="mlquantify.T50"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T50</span></code></a></p></td>
<td><p>Threshold 50. This method tries to</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.MS" title="mlquantify.MS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MS</span></code></a></p></td>
<td><p>Median Sweep. This method uses an</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.MS2" title="mlquantify.MS2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MS2</span></code></a></p></td>
<td><p>Median Sweep 2. It relies on the same</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.PACC" title="mlquantify.PACC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PACC</span></code></a></p></td>
<td><p>Probabilistic Adjusted Classify and Count.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.HDy" title="mlquantify.HDy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HDy</span></code></a></p></td>
<td><p>Hellinger Distance Minimization. The method</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.DyS" title="mlquantify.DyS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DyS</span></code></a></p></td>
<td><p>Distribution y-Similarity framework. Is a</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.SORD" title="mlquantify.SORD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SORD</span></code></a></p></td>
<td><p>Sample Ordinal Distance. Is a method</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.SMM" title="mlquantify.SMM"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SMM</span></code></a></p></td>
<td><p>Sample Mean Matching. The method is</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.DySsyn" title="mlquantify.DySsyn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DySsyn</span></code></a></p></td>
<td><p>Synthetic Distribution y-Similarity. This method works the</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.HDx" title="mlquantify.HDx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HDx</span></code></a></p></td>
<td><p>Hellinger Distance Minimization. The method is similar</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.Ensemble" title="mlquantify.Ensemble"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ensemble</span></code></a></p></td>
<td><p>Abstract Class for quantifiers.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.GridSearchQ" title="mlquantify.GridSearchQ"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GridSearchQ</span></code></a></p></td>
<td><p>Hyperparameter optimization for quantification models using grid search.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading"></a></h2>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.absolute_error" title="mlquantify.absolute_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">absolute_error</span></code></a>(prev_real, prev_pred)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.kullback_leibler_divergence" title="mlquantify.kullback_leibler_divergence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kullback_leibler_divergence</span></code></a>(prev_real, prev_pred)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.normalized_kullback_leibler_divergence" title="mlquantify.normalized_kullback_leibler_divergence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalized_kullback_leibler_divergence</span></code></a>(prev_real, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.relative_absolute_error" title="mlquantify.relative_absolute_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">relative_absolute_error</span></code></a>(prev_real, prev_pred)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.normalized_absolute_error" title="mlquantify.normalized_absolute_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalized_absolute_error</span></code></a>(prev_real, prev_pred)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.bias" title="mlquantify.bias"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bias</span></code></a>(prev_real, prev_pred)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.normalized_relative_absolute_error" title="mlquantify.normalized_relative_absolute_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalized_relative_absolute_error</span></code></a>(prev_real, prev_pred)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.squared_error" title="mlquantify.squared_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">squared_error</span></code></a>(prev_real, prev_pred)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.mean_squared_error" title="mlquantify.mean_squared_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_squared_error</span></code></a>(prev_real, prev_pred)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.get_measure" title="mlquantify.get_measure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_measure</span></code></a>(measure)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.get_method" title="mlquantify.get_method"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_method</span></code></a>(method)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.normalize_prevalence" title="mlquantify.normalize_prevalence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_prevalence</span></code></a>(prevalences, classes)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.parallel" title="mlquantify.parallel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">parallel</span></code></a>(func, elements[, n_jobs])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.get_real_prev" title="mlquantify.get_real_prev"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_real_prev</span></code></a>(→ dict)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.make_prevs" title="mlquantify.make_prevs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_prevs</span></code></a>(→ list)</p></td>
<td><p>Generate a list of n_dim values uniformly distributed between 0 and 1 that sum exactly to 1.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.generate_artificial_indexes" title="mlquantify.generate_artificial_indexes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generate_artificial_indexes</span></code></a>(y, prevalence, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.round_protocol_df" title="mlquantify.round_protocol_df"><code class="xref py py-obj docutils literal notranslate"><span class="pre">round_protocol_df</span></code></a>(dataframe[, frac])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.convert_columns_to_arrays" title="mlquantify.convert_columns_to_arrays"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_columns_to_arrays</span></code></a>(df[, columns])</p></td>
<td><p>Converts the specified columns from string of arrays to numpy arrays</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.load_quantifier" title="mlquantify.load_quantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_quantifier</span></code></a>(path)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.getHist" title="mlquantify.getHist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getHist</span></code></a>(scores, nbins)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.sqEuclidean" title="mlquantify.sqEuclidean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sqEuclidean</span></code></a>(dist1, dist2)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.probsymm" title="mlquantify.probsymm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">probsymm</span></code></a>(dist1, dist2)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.hellinger" title="mlquantify.hellinger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hellinger</span></code></a>(dist1, dist2)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.topsoe" title="mlquantify.topsoe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">topsoe</span></code></a>(dist1, dist2)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.ternary_search" title="mlquantify.ternary_search"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ternary_search</span></code></a>(left, right, f[, eps])</p></td>
<td><p>This function applies Ternary search</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.compute_table" title="mlquantify.compute_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_table</span></code></a>(y, y_pred, classes)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.compute_tpr" title="mlquantify.compute_tpr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_tpr</span></code></a>(TP, FN)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.compute_fpr" title="mlquantify.compute_fpr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_fpr</span></code></a>(FP, TN)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.adjust_threshold" title="mlquantify.adjust_threshold"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjust_threshold</span></code></a>(→ tuple)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.get_scores" title="mlquantify.get_scores"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_scores</span></code></a>(→ tuple)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.MoSS" title="mlquantify.MoSS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MoSS</span></code></a>(n, alpha, m)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.protocol_boxplot" title="mlquantify.protocol_boxplot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">protocol_boxplot</span></code></a>(table_protocol, x, y[, methods, ...])</p></td>
<td><p>Plots a boxplot based on the provided DataFrame and selected methods.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlquantify.protocol_lineplot" title="mlquantify.protocol_lineplot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">protocol_lineplot</span></code></a>(table_protocol, methods, x, y[, ...])</p></td>
<td><p>Plots a line plot based on the provided DataFrame of the protocol and selected methods.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlquantify.class_distribution_plot" title="mlquantify.class_distribution_plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">class_distribution_plot</span></code></a>(values, labels[, bins, title, ...])</p></td>
<td><p>Plot overlaid histograms of class distributions.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="package-contents">
<h2>Package Contents<a class="headerlink" href="#package-contents" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.PWKCLF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">PWKCLF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.PWKCLF" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">sklearn.base.BaseEstimator</span></code></p>
<p>Learner based on k-Nearest Neighborst (KNN) to use on the method PWK,
that also is based on KNN.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.PWKCLF.alpha">
<span class="sig-name descname"><span class="pre">alpha</span></span><a class="headerlink" href="#mlquantify.PWKCLF.alpha" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.PWKCLF.n_neighbors">
<span class="sig-name descname"><span class="pre">n_neighbors</span></span><a class="headerlink" href="#mlquantify.PWKCLF.n_neighbors" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.PWKCLF.nbrs">
<span class="sig-name descname"><span class="pre">nbrs</span></span><a class="headerlink" href="#mlquantify.PWKCLF.nbrs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.PWKCLF.Y">
<span class="sig-name descname"><span class="pre">Y</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.PWKCLF.Y" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.PWKCLF.Y_map">
<span class="sig-name descname"><span class="pre">Y_map</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.PWKCLF.Y_map" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.PWKCLF.w">
<span class="sig-name descname"><span class="pre">w</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.PWKCLF.w" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.PWKCLF.y">
<span class="sig-name descname"><span class="pre">y</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.PWKCLF.y" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.PWKCLF.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.PWKCLF.fit" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.PWKCLF.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.PWKCLF.predict" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.absolute_error">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">absolute_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prev_real</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prev_pred</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.absolute_error" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.kullback_leibler_divergence">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">kullback_leibler_divergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prev_real</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prev_pred</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.kullback_leibler_divergence" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.normalized_kullback_leibler_divergence">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">normalized_kullback_leibler_divergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prev_real</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prev_pred</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.normalized_kullback_leibler_divergence" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.relative_absolute_error">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">relative_absolute_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prev_real</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prev_pred</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.relative_absolute_error" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.normalized_absolute_error">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">normalized_absolute_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prev_real</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prev_pred</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.normalized_absolute_error" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.bias">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">bias</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prev_real</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prev_pred</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.bias" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.normalized_relative_absolute_error">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">normalized_relative_absolute_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prev_real</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prev_pred</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.normalized_relative_absolute_error" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.squared_error">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">squared_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prev_real</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prev_pred</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.squared_error" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.mean_squared_error">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">mean_squared_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prev_real</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prev_pred</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.any</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.mean_squared_error" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mlquantify.MEASURES">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">MEASURES</span></span><a class="headerlink" href="#mlquantify.MEASURES" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.get_measure">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">get_measure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.get_measure" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.APP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">APP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">models</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="base/index.html#mlquantify.base.Quantifier" title="mlquantify.base.Quantifier"><span class="pre">mlquantify.base.Quantifier</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="base/index.html#mlquantify.base.Quantifier" title="mlquantify.base.Quantifier"><span class="pre">mlquantify.base.Quantifier</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_prevs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iterations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'predictions'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.APP" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="evaluation/protocol/_Protocol/index.html#mlquantify.evaluation.protocol._Protocol.Protocol" title="mlquantify.evaluation.protocol._Protocol.Protocol"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.evaluation.protocol._Protocol.Protocol</span></code></a></p>
<p>Artificial Prevalence Protocol. It splits a test into several
samples varying prevalence and sample size, with n iterations.
For a list of Quantifiers, it computes training and testing
for each one and returns either a table of results with error measures
or just the predictions.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.APP.n_prevs">
<span class="sig-name descname"><span class="pre">n_prevs</span></span><a class="headerlink" href="#mlquantify.APP.n_prevs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.APP.predict_protocol">
<span class="sig-name descname"><span class="pre">predict_protocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_test</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.APP.predict_protocol" title="Link to this definition"></a></dt>
<dd><p>Generates several samples with artificial prevalences and sizes.
For each model, predicts with this sample, aggregating all together
with a pandas dataframe if requested, or else just the predictions.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X_test (array-like): Features of the test set.
y_test (array-like): Labels of the test set.</p>
</dd>
<dt>Returns:</dt><dd><p>tuple: predictions containing the model name, real prev, pred prev, and batch size</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.APP._new_sample">
<span class="sig-name descname"><span class="pre">_new_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prev</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.APP._new_sample" title="Link to this definition"></a></dt>
<dd><p>Generates a new sample with a specified prevalence and size.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Features from which to take the new sample.
y (array-like): Labels from which to take the new sample.
prev (List[float]): The specified prevalences.
batch_size (int): Sample size.</p>
</dd>
<dt>Returns:</dt><dd><p>tuple: New sample’s features and labels.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.APP._delayed_predict">
<span class="sig-name descname"><span class="pre">_delayed_predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.APP._delayed_predict" title="Link to this definition"></a></dt>
<dd><p>Method predicts into the new sample, is delayed for running
in parallel for eficciency purposes</p>
<dl class="simple">
<dt>Args:</dt><dd><p>args (Any): arguments to use</p>
</dd>
<dt>Returns:</dt><dd><p>tuple: returns the (method name, real_prev, pred_prev and sample_size)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.APP._generate_artificial_prevalences">
<span class="sig-name descname"><span class="pre">_generate_artificial_prevalences</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_prev</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#mlquantify.APP._generate_artificial_prevalences" title="Link to this definition"></a></dt>
<dd><p>Generates n artificial prevalences with n dimensions.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>n_dim (int): Number of dimensions for the artificial prevalence.
n_prev (int): Number of prevalence points to generate.
n_iter (int): Number of iterations.</p>
</dd>
<dt>Returns:</dt><dd><p>np.ndarray: Generated artificial prevalences.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.APP._generate_args">
<span class="sig-name descname"><span class="pre">_generate_args</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.APP._generate_args" title="Link to this definition"></a></dt>
<dd><p>Generates arguments for parallel processing based on the model, prevalence, and batch size.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X_test (array-like): Features of the test set.
y_test (array-like): Labels of the test set.
prevs (np.ndarray): Artificial prevalences generated.</p>
</dd>
<dt>Returns:</dt><dd><p>List[tuple]: List of arguments for parallel processing.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.NPP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">NPP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">models</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="base/index.html#mlquantify.base.Quantifier" title="mlquantify.base.Quantifier"><span class="pre">mlquantify.base.Quantifier</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="base/index.html#mlquantify.base.Quantifier" title="mlquantify.base.Quantifier"><span class="pre">mlquantify.base.Quantifier</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iterations</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'predictions'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measures</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.NPP" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="evaluation/protocol/_Protocol/index.html#mlquantify.evaluation.protocol._Protocol.Protocol" title="mlquantify.evaluation.protocol._Protocol.Protocol"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.evaluation.protocol._Protocol.Protocol</span></code></a></p>
<p>Base class for implementing different quantification protocols.</p>
<p>This abstract class provides a structure for creating protocols that involve
fitting quantification models to training data and generating predictions on test data.
It supports parallel processing, multiple iterations, and different output formats.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>models (Union[List[Union[str, Quantifier]], str, Quantifier]):</dt><dd><p>List of quantification models, a single model name, or ‘all’ for all models.</p>
</dd>
<dt>batch_size (Union[List[int], int]):</dt><dd><p>Size of the batches to be processed, or a list of sizes.</p>
</dd>
<dt>learner (BaseEstimator, optional):</dt><dd><p>Machine learning model to be used with the quantifiers. Required for model methods.</p>
</dd>
<dt>n_iterations (int, optional):</dt><dd><p>Number of iterations for the protocol. Default is 1.</p>
</dd>
<dt>n_jobs (int, optional):</dt><dd><p>Number of jobs to run in parallel. Default is 1.</p>
</dd>
<dt>random_state (int, optional):</dt><dd><p>Seed for random number generation. Default is 32.</p>
</dd>
<dt>verbose (bool, optional):</dt><dd><p>Whether to print progress messages. Default is False.</p>
</dd>
<dt>return_type (str, optional):</dt><dd><p>Type of return value (‘predictions’ or ‘table’). Default is ‘predictions’.</p>
</dd>
<dt>measures (List[str], optional):</dt><dd><p>List of error measures to calculate. Must be in MEASURES or None. Default is None.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.NPP.predict_protocol">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">predict_protocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_test</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_test</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.NPP.predict_protocol" title="Link to this definition"></a></dt>
<dd><p>Abstract method that every protocol has to implement</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.NPP._new_sample">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">_new_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prev</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.NPP._new_sample" title="Link to this definition"></a></dt>
<dd><p>Abstract method of sample extraction for each protocol</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>tuple: tuple containing the X_sample and the y_sample</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.NPP._delayed_predict">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">_delayed_predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.NPP._delayed_predict" title="Link to this definition"></a></dt>
<dd><p>abstract method for predicting in the extracted
samples, is delayed for running in parallel for
eficciency purposes.</p>
</dd></dl>

</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mlquantify.AGGREGATIVE">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">AGGREGATIVE</span></span><a class="headerlink" href="#mlquantify.AGGREGATIVE" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mlquantify.NON_AGGREGATIVE">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">NON_AGGREGATIVE</span></span><a class="headerlink" href="#mlquantify.NON_AGGREGATIVE" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mlquantify.META">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">META</span></span><a class="headerlink" href="#mlquantify.META" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mlquantify.METHODS">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">METHODS</span></span><a class="headerlink" href="#mlquantify.METHODS" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.get_method">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">get_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.get_method" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.CC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">CC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.CC" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="base/index.html#mlquantify.base.AggregativeQuantifier" title="mlquantify.base.AggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.AggregativeQuantifier</span></code></a></p>
<p>Classify and Count. The simplest quantification method
involves classifying each instance and then counting the
number of instances assigned to each class to estimate
the class prevalence.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.CC.learner">
<span class="sig-name descname"><span class="pre">learner</span></span><a class="headerlink" href="#mlquantify.CC.learner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.CC._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.CC._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.CC._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.CC._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.PCC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">PCC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.PCC" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="base/index.html#mlquantify.base.AggregativeQuantifier" title="mlquantify.base.AggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.AggregativeQuantifier</span></code></a></p>
<p>Probabilistic Classify and Count. This method
takes the probabilistic predictions and takes the
mean of them for each class.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.PCC.learner">
<span class="sig-name descname"><span class="pre">learner</span></span><a class="headerlink" href="#mlquantify.PCC.learner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.PCC._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.PCC._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.PCC._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.PCC._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.GAC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">GAC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.GAC" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="base/index.html#mlquantify.base.AggregativeQuantifier" title="mlquantify.base.AggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.AggregativeQuantifier</span></code></a></p>
<p>Generalized Adjusted Count. It applies a
classifier to build a system of linear equations,
and solve it via constrained least-squares regression.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GAC.learner">
<span class="sig-name descname"><span class="pre">learner</span></span><a class="headerlink" href="#mlquantify.GAC.learner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GAC.cond_prob_matrix">
<span class="sig-name descname"><span class="pre">cond_prob_matrix</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.GAC.cond_prob_matrix" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GAC.train_size">
<span class="sig-name descname"><span class="pre">train_size</span></span><a class="headerlink" href="#mlquantify.GAC.train_size" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GAC.random_state">
<span class="sig-name descname"><span class="pre">random_state</span></span><a class="headerlink" href="#mlquantify.GAC.random_state" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GAC._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.GAC._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GAC._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.GAC._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GAC.get_cond_prob_matrix">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_cond_prob_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_labels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#mlquantify.GAC.get_cond_prob_matrix" title="Link to this definition"></a></dt>
<dd><p>Estimate the conditional probability matrix P(yi|yj)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GAC.solve_adjustment">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solve_adjustment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cond_prob_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predicted_prevalences</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.GAC.solve_adjustment" title="Link to this definition"></a></dt>
<dd><p>Solve the linear system Ax = B with A=cond_prob_matrix and B=predicted_prevalences</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.GPAC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">GPAC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.GPAC" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="base/index.html#mlquantify.base.AggregativeQuantifier" title="mlquantify.base.AggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.AggregativeQuantifier</span></code></a></p>
<p>Generalized Probabilistic Adjusted Count. Like
GAC, it also build a system of linear equations, but
utilize the confidence scores from probabilistic
classifiers as in the PAC method.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GPAC.learner">
<span class="sig-name descname"><span class="pre">learner</span></span><a class="headerlink" href="#mlquantify.GPAC.learner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GPAC.cond_prob_matrix">
<span class="sig-name descname"><span class="pre">cond_prob_matrix</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.GPAC.cond_prob_matrix" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GPAC.train_size">
<span class="sig-name descname"><span class="pre">train_size</span></span><a class="headerlink" href="#mlquantify.GPAC.train_size" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GPAC.random_state">
<span class="sig-name descname"><span class="pre">random_state</span></span><a class="headerlink" href="#mlquantify.GPAC.random_state" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GPAC._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.GPAC._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GPAC._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.GPAC._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GPAC.get_cond_prob_matrix">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_cond_prob_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_labels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_pred</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#mlquantify.GPAC.get_cond_prob_matrix" title="Link to this definition"></a></dt>
<dd><p>Estimate the matrix where entry (i,j) is the estimate of P(yi|yj)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.FM">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">FM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.FM" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="base/index.html#mlquantify.base.AggregativeQuantifier" title="mlquantify.base.AggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.AggregativeQuantifier</span></code></a></p>
<p>The Friedman Method. Similar to GPAC,
but instead of averaging the confidence scores
from probabilistic classifiers, it uses the proportion
of confidence scores that are higher or lower than the
expected class frequencies found in the training data.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.FM.learner">
<span class="sig-name descname"><span class="pre">learner</span></span><a class="headerlink" href="#mlquantify.FM.learner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.FM.CM">
<span class="sig-name descname"><span class="pre">CM</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.FM.CM" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.FM._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.FM._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.FM._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.FM._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.EMQ">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">EMQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.EMQ" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="base/index.html#mlquantify.base.AggregativeQuantifier" title="mlquantify.base.AggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.AggregativeQuantifier</span></code></a></p>
<p>Expectation Maximisation Quantifier. It is a method that
ajust the priors and posteriors probabilities of a learner</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.EMQ.MAX_ITER">
<span class="sig-name descname"><span class="pre">MAX_ITER</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1000</span></em><a class="headerlink" href="#mlquantify.EMQ.MAX_ITER" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.EMQ.EPSILON">
<span class="sig-name descname"><span class="pre">EPSILON</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-06</span></em><a class="headerlink" href="#mlquantify.EMQ.EPSILON" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.EMQ.learner">
<span class="sig-name descname"><span class="pre">learner</span></span><a class="headerlink" href="#mlquantify.EMQ.learner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.EMQ.priors">
<span class="sig-name descname"><span class="pre">priors</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.EMQ.priors" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.EMQ._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.EMQ._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.EMQ._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.EMQ._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.EMQ.predict_proba">
<span class="sig-name descname"><span class="pre">predict_proba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">EPSILON</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">MAX_ITER</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span></span></span><a class="headerlink" href="#mlquantify.EMQ.predict_proba" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.EMQ.EM">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">EM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">priors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">posteriors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">EPSILON</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">MAX_ITER</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.EMQ.EM" title="Link to this definition"></a></dt>
<dd><p>Expectaion Maximization function, it iterates several times
and At each iteration step, both the a posteriori and the a
priori probabilities are reestimated sequentially for each new
observation and each class. The iterative procedure proceeds
until the convergence of the estimated probabilities.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>priors (array-like): priors probabilites of the train.
posteriors (array-like): posteriors probabiblities of the test.
epsilon (float): value that helps to indify the convergence.
max_iter (int): max number of iterations.</p>
</dd>
<dt>Returns:</dt><dd><p>the predicted prevalence and the ajusted posteriors.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.PWK">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">PWK</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.PWK" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="base/index.html#mlquantify.base.AggregativeQuantifier" title="mlquantify.base.AggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.AggregativeQuantifier</span></code></a></p>
<p>Nearest-Neighbor based Quantification. This method
is based on nearest-neighbor based classification to the
setting of quantification. In this k-NN approach, it applies
a weighting scheme which applies less weight on neighbors
from the majority class.
Must be used with PWKCLF to work as expected.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.PWK.learner">
<span class="sig-name descname"><span class="pre">learner</span></span><a class="headerlink" href="#mlquantify.PWK.learner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.PWK._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.PWK._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.PWK._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.PWK._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.ACC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">ACC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.ACC" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="methods/aggregative/ThreholdOptm/_ThreholdOptimization/index.html#mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization" title="mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization</span></code></a></p>
<p>Adjusted Classify and Count or Adjusted Count. Is a
base method for the threhold methods.</p>
<blockquote>
<div><p>As described on the Threshold base class, this method</p>
</div></blockquote>
<p>estimate the true positive and false positive rates from
the training data and utilize them to adjust the output
of the CC method.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.ACC.threshold">
<span class="sig-name descname"><span class="pre">threshold</span></span><a class="headerlink" href="#mlquantify.ACC.threshold" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.ACC.best_tprfpr">
<span class="sig-name descname"><span class="pre">best_tprfpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.ACC.best_tprfpr" title="Link to this definition"></a></dt>
<dd><p>Abstract method for determining the best TPR and FPR to use in the equation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.MAX">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">MAX</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.MAX" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="methods/aggregative/ThreholdOptm/_ThreholdOptimization/index.html#mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization" title="mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization</span></code></a></p>
<p>Threshold MAX. This method tries to use the
threshold where it maximizes the difference between
tpr and fpr to use in the denominator of the equation.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.MAX.best_tprfpr">
<span class="sig-name descname"><span class="pre">best_tprfpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.MAX.best_tprfpr" title="Link to this definition"></a></dt>
<dd><p>Abstract method for determining the best TPR and FPR to use in the equation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.X_method">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">X_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.X_method" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="methods/aggregative/ThreholdOptm/_ThreholdOptimization/index.html#mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization" title="mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization</span></code></a></p>
<p>Threshold X. This method tries to
use the threshold where fpr = 1 - tpr</p>
<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.X_method.best_tprfpr">
<span class="sig-name descname"><span class="pre">best_tprfpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.X_method.best_tprfpr" title="Link to this definition"></a></dt>
<dd><p>Abstract method for determining the best TPR and FPR to use in the equation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.T50">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">T50</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.T50" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="methods/aggregative/ThreholdOptm/_ThreholdOptimization/index.html#mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization" title="mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization</span></code></a></p>
<p>Threshold 50. This method tries to
use the threshold where tpr = 0.5.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.T50.best_tprfpr">
<span class="sig-name descname"><span class="pre">best_tprfpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.T50.best_tprfpr" title="Link to this definition"></a></dt>
<dd><p>Abstract method for determining the best TPR and FPR to use in the equation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.MS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">MS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.MS" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="methods/aggregative/ThreholdOptm/_ThreholdOptimization/index.html#mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization" title="mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization</span></code></a></p>
<p>Median Sweep. This method uses an
ensemble of such threshold-based methods and
takes the median prediction.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.MS.threshold">
<span class="sig-name descname"><span class="pre">threshold</span></span><a class="headerlink" href="#mlquantify.MS.threshold" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.MS.best_tprfpr">
<span class="sig-name descname"><span class="pre">best_tprfpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.MS.best_tprfpr" title="Link to this definition"></a></dt>
<dd><p>Abstract method for determining the best TPR and FPR to use in the equation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.MS2">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">MS2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.MS2" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="methods/aggregative/ThreholdOptm/_ThreholdOptimization/index.html#mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization" title="mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization</span></code></a></p>
<p>Median Sweep 2. It relies on the same
strategy of the Median Sweep, but compute
the median only for cases in which
tpr -fpr &gt; 0.25</p>
<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.MS2.best_tprfpr">
<span class="sig-name descname"><span class="pre">best_tprfpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.MS2.best_tprfpr" title="Link to this definition"></a></dt>
<dd><p>Abstract method for determining the best TPR and FPR to use in the equation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.PACC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">PACC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.PACC" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="methods/aggregative/ThreholdOptm/_ThreholdOptimization/index.html#mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization" title="mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.ThreholdOptm._ThreholdOptimization.ThresholdOptimization</span></code></a></p>
<p>Probabilistic Adjusted Classify and Count.
This method adapts the AC approach by using average
classconditional confidences from a probabilistic
classifier instead of true positive and false positive rates.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.PACC.threshold">
<span class="sig-name descname"><span class="pre">threshold</span></span><a class="headerlink" href="#mlquantify.PACC.threshold" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.PACC._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.PACC._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.PACC.best_tprfpr">
<span class="sig-name descname"><span class="pre">best_tprfpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thresholds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fprs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.PACC.best_tprfpr" title="Link to this definition"></a></dt>
<dd><p>Abstract method for determining the best TPR and FPR to use in the equation</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.HDy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">HDy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.HDy" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="methods/aggregative/mixtureModels/_MixtureModel/index.html#mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel" title="mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel</span></code></a></p>
<p>Hellinger Distance Minimization. The method
is based on computing the hellinger distance of
two distributions, test distribution and the mixture
of the positive and negative distribution of the train.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.HDy._compute_prevalence">
<span class="sig-name descname"><span class="pre">_compute_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#mlquantify.HDy._compute_prevalence" title="Link to this definition"></a></dt>
<dd><p>Abstract method for computing the prevalence using the test scores</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.HDy.best_distance">
<span class="sig-name descname"><span class="pre">best_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_test</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#mlquantify.HDy.best_distance" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.HDy.GetMinDistancesHDy">
<span class="sig-name descname"><span class="pre">GetMinDistancesHDy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.HDy.GetMinDistancesHDy" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.DyS">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">DyS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'topsoe'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.DyS" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="methods/aggregative/mixtureModels/_MixtureModel/index.html#mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel" title="mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel</span></code></a></p>
<p>Distribution y-Similarity framework. Is a
method that generalises the HDy approach by
considering the dissimilarity function DS as
a parameter of the model</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.DyS.bins_size">
<span class="sig-name descname"><span class="pre">bins_size</span></span><a class="headerlink" href="#mlquantify.DyS.bins_size" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.DyS.measure">
<span class="sig-name descname"><span class="pre">measure</span></span><a class="headerlink" href="#mlquantify.DyS.measure" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.DyS.prevs">
<span class="sig-name descname"><span class="pre">prevs</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.DyS.prevs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.DyS._compute_prevalence">
<span class="sig-name descname"><span class="pre">_compute_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#mlquantify.DyS._compute_prevalence" title="Link to this definition"></a></dt>
<dd><p>Abstract method for computing the prevalence using the test scores</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.DyS.best_distance">
<span class="sig-name descname"><span class="pre">best_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_test</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#mlquantify.DyS.best_distance" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.DyS.GetMinDistancesDyS">
<span class="sig-name descname"><span class="pre">GetMinDistancesDyS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlquantify.DyS.GetMinDistancesDyS" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.SORD">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">SORD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.SORD" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="methods/aggregative/mixtureModels/_MixtureModel/index.html#mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel" title="mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel</span></code></a></p>
<p>Sample Ordinal Distance. Is a method
that does not rely on distributions, but
estimates the prevalence of the positive
class in a test dataset by calculating and
minimizing a sample ordinal distance measure
between the test scores and known positive
and negative scores.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.SORD.best_distance_index">
<span class="sig-name descname"><span class="pre">best_distance_index</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.SORD.best_distance_index" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.SORD._compute_prevalence">
<span class="sig-name descname"><span class="pre">_compute_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#mlquantify.SORD._compute_prevalence" title="Link to this definition"></a></dt>
<dd><p>Abstract method for computing the prevalence using the test scores</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.SORD._calculate_distances">
<span class="sig-name descname"><span class="pre">_calculate_distances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.SORD._calculate_distances" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.SMM">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">SMM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.SMM" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="methods/aggregative/mixtureModels/_MixtureModel/index.html#mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel" title="mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel</span></code></a></p>
<p>Sample Mean Matching. The method is
a member of the DyS framework that uses
simple means to represent the score
distribution for positive, negative
and unlabelled scores.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.SMM._compute_prevalence">
<span class="sig-name descname"><span class="pre">_compute_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#mlquantify.SMM._compute_prevalence" title="Link to this definition"></a></dt>
<dd><p>Abstract method for computing the prevalence using the test scores</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.DySsyn">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">DySsyn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">learner</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">sklearn.base.BaseEstimator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'topsoe'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">merge_factor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_train</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.DySsyn" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="methods/aggregative/mixtureModels/_MixtureModel/index.html#mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel" title="mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.methods.aggregative.mixtureModels._MixtureModel.MixtureModel</span></code></a></p>
<p>Synthetic Distribution y-Similarity. This method works the
same as DyS method, but istead of using the train scores, it
generates them via MoSS (Model for Score Simulation) which
generate a spectrum of score distributions from highly separated
scores to fully mixed scores.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.DySsyn.bins_size">
<span class="sig-name descname"><span class="pre">bins_size</span></span><a class="headerlink" href="#mlquantify.DySsyn.bins_size" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.DySsyn.merge_factor">
<span class="sig-name descname"><span class="pre">merge_factor</span></span><a class="headerlink" href="#mlquantify.DySsyn.merge_factor" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.DySsyn.alpha_train">
<span class="sig-name descname"><span class="pre">alpha_train</span></span><a class="headerlink" href="#mlquantify.DySsyn.alpha_train" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.DySsyn.n">
<span class="sig-name descname"><span class="pre">n</span></span><a class="headerlink" href="#mlquantify.DySsyn.n" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.DySsyn.measure">
<span class="sig-name descname"><span class="pre">measure</span></span><a class="headerlink" href="#mlquantify.DySsyn.measure" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.DySsyn.m">
<span class="sig-name descname"><span class="pre">m</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.DySsyn.m" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.DySsyn._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.DySsyn._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.DySsyn._compute_prevalence">
<span class="sig-name descname"><span class="pre">_compute_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#mlquantify.DySsyn._compute_prevalence" title="Link to this definition"></a></dt>
<dd><p>Abstract method for computing the prevalence using the test scores</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.DySsyn.best_distance">
<span class="sig-name descname"><span class="pre">best_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.DySsyn.best_distance" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.DySsyn.GetMinDistancesDySsyn">
<span class="sig-name descname"><span class="pre">GetMinDistancesDySsyn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_scores</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlquantify.DySsyn.GetMinDistancesDySsyn" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.HDx">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">HDx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bins_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.HDx" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="base/index.html#mlquantify.base.NonAggregativeQuantifier" title="mlquantify.base.NonAggregativeQuantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.NonAggregativeQuantifier</span></code></a></p>
<p>Hellinger Distance Minimization. The method is similar
to the HDy method, but istead of computing the hellinger
distance of the scores (generated via classifier), HDx
computes the distance of each one of the features of the
dataset</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.HDx.bins_size">
<span class="sig-name descname"><span class="pre">bins_size</span></span><a class="headerlink" href="#mlquantify.HDx.bins_size" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.HDx.neg_features">
<span class="sig-name descname"><span class="pre">neg_features</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.HDx.neg_features" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.HDx.pos_features">
<span class="sig-name descname"><span class="pre">pos_features</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.HDx.pos_features" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.HDx._fit_method">
<span class="sig-name descname"><span class="pre">_fit_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.HDx._fit_method" title="Link to this definition"></a></dt>
<dd><p>Abstract fit method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.
learner_fitted (bool): Whether the learner is already fitted.
cv_folds (int): Number of cross-validation folds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.HDx._predict_method">
<span class="sig-name descname"><span class="pre">_predict_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.HDx._predict_method" title="Link to this definition"></a></dt>
<dd><p>Abstract predict method that each quantification method must implement.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Test data to generate class prevalences.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Dictionary with class:prevalence for each class.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.Ensemble">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">Ensemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quantifier</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="base/index.html#mlquantify.base.Quantifier" title="mlquantify.base.Quantifier"><span class="pre">mlquantify.base.Quantifier</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_prop</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selection_metric</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'all'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_metric</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_sample_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_trials</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.Ensemble" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="base/index.html#mlquantify.base.Quantifier" title="mlquantify.base.Quantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.Quantifier</span></code></a></p>
<p>Abstract Class for quantifiers.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.Ensemble.SELECTION_METRICS">
<span class="sig-name descname"><span class="pre">SELECTION_METRICS</span></span><a class="headerlink" href="#mlquantify.Ensemble.SELECTION_METRICS" title="Link to this definition"></a></dt>
<dd><p>Ensemble method, based on the articles:
Pérez-Gállego, P., Quevedo, J. R., &amp; del Coz, J. J. (2017).
Using ensembles for problems with characterizable changes in data distribution: A case study on quantification.
Information Fusion, 34, 87-100.
and
Pérez-Gállego, P., Castano, A., Quevedo, J. R., &amp; del Coz, J. J. (2019).
Dynamic ensemble selection for quantification tasks.
Information Fusion, 45, 1-15.</p>
<blockquote>
<div><p>This approach of Ensemble is made of taking multiple</p>
</div></blockquote>
<p>samples varying class proportions on each, and for the
predictions, it takes the k models which as the minimum
seletion metric, which are:</p>
<blockquote>
<div><ul class="simple">
<li><p>all -&gt; return all the predictions</p></li>
<li><p>ptr -&gt; computes the selected error measure</p></li>
<li><p>ds -&gt; computes the hellinger distance of the train and test</p></li>
</ul>
<p>distributions for each model</p>
</div></blockquote>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.Ensemble.base_quantifier">
<span class="sig-name descname"><span class="pre">base_quantifier</span></span><a class="headerlink" href="#mlquantify.Ensemble.base_quantifier" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.Ensemble.size">
<span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#mlquantify.Ensemble.size" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.Ensemble.min_prop">
<span class="sig-name descname"><span class="pre">min_prop</span></span><a class="headerlink" href="#mlquantify.Ensemble.min_prop" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.Ensemble.p_metric">
<span class="sig-name descname"><span class="pre">p_metric</span></span><a class="headerlink" href="#mlquantify.Ensemble.p_metric" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.Ensemble.selection_metric">
<span class="sig-name descname"><span class="pre">selection_metric</span></span><a class="headerlink" href="#mlquantify.Ensemble.selection_metric" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.Ensemble.return_type">
<span class="sig-name descname"><span class="pre">return_type</span></span><a class="headerlink" href="#mlquantify.Ensemble.return_type" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.Ensemble.n_jobs">
<span class="sig-name descname"><span class="pre">n_jobs</span></span><a class="headerlink" href="#mlquantify.Ensemble.n_jobs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.Ensemble.proba_generator">
<span class="sig-name descname"><span class="pre">proba_generator</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlquantify.Ensemble.proba_generator" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.Ensemble.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#mlquantify.Ensemble.verbose" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.Ensemble.max_sample_size">
<span class="sig-name descname"><span class="pre">max_sample_size</span></span><a class="headerlink" href="#mlquantify.Ensemble.max_sample_size" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.Ensemble.max_trials">
<span class="sig-name descname"><span class="pre">max_trials</span></span><a class="headerlink" href="#mlquantify.Ensemble.max_trials" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.Ensemble.sout">
<span class="sig-name descname"><span class="pre">sout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.Ensemble.sout" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.Ensemble.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.Ensemble.fit" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.Ensemble.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.Ensemble.predict" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.Ensemble.ptr_selection_metric">
<span class="sig-name descname"><span class="pre">ptr_selection_metric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevalences</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.Ensemble.ptr_selection_metric" title="Link to this definition"></a></dt>
<dd><p>Selects the prevalences made by models that have been trained on samples with a prevalence that is most similar
to a first approximation of the test prevalence as made by all models in the ensemble.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.Ensemble.ds_get_posteriors">
<span class="sig-name descname"><span class="pre">ds_get_posteriors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.Ensemble.ds_get_posteriors" title="Link to this definition"></a></dt>
<dd><p>In the original article, this procedure is not described in a sufficient level of detail. The paper only says
that the distribution of posterior probabilities from training and test examples is compared by means of the
Hellinger Distance. However, how these posterior probabilities are generated is not specified. In the article,
a Logistic Regressor (LR) is used as the classifier device and that could be used for this purpose. However, in
general, a Quantifier is not necessarily an instance of Aggreggative Probabilistic Quantifiers, and so, that the
quantifier builds on top of a probabilistic classifier cannot be given for granted. Additionally, it would not
be correct to generate the posterior probabilities for training documents that have concurred in training the
classifier that generates them.
This function thus generates the posterior probabilities for all training documents in a cross-validation way,
using a LR with hyperparameters that have previously been optimized via grid search in 5FCV.
:return P,f, where P is a ndarray containing the posterior probabilities of the training data, generated via
cross-validation and using an optimized LR, and the function to be used in order to generate posterior
probabilities for test X.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.Ensemble.ds_selection_metric">
<span class="sig-name descname"><span class="pre">ds_selection_metric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevalences</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.Ensemble.ds_selection_metric" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.normalize_prevalence">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">normalize_prevalence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevalences</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.normalize_prevalence" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.parallel">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">parallel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elements</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.parallel" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.get_real_prev">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">get_real_prev</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#mlquantify.get_real_prev" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.make_prevs">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">make_prevs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ndim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#mlquantify.make_prevs" title="Link to this definition"></a></dt>
<dd><p>Generate a list of n_dim values uniformly distributed between 0 and 1 that sum exactly to 1.</p>
<p>Args:
n_dim (int): Number of values in the list.</p>
<p>Returns:
list: List of n_dim values that sum to 1.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.generate_artificial_indexes">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">generate_artificial_indexes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevalence</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.generate_artificial_indexes" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.round_protocol_df">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">round_protocol_df</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataframe</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pandas.DataFrame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frac</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.round_protocol_df" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.convert_columns_to_arrays">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">convert_columns_to_arrays</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">columns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">['PRED_PREVS',</span> <span class="pre">'REAL_PREVS']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.convert_columns_to_arrays" title="Link to this definition"></a></dt>
<dd><p>Converts the specified columns from string of arrays to numpy arrays</p>
<dl class="simple">
<dt>Args:</dt><dd><p>df (array-like): the dataframe from which to change convert the coluns
columns (list, optional): the coluns with string of arrays, default is the options for
the protocol dataframes</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.load_quantifier">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">load_quantifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.load_quantifier" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.getHist">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">getHist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scores</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.getHist" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.sqEuclidean">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">sqEuclidean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dist1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.sqEuclidean" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.probsymm">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">probsymm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dist1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.probsymm" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.hellinger">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">hellinger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dist1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.hellinger" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.topsoe">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">topsoe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dist1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.topsoe" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.ternary_search">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">ternary_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.ternary_search" title="Link to this definition"></a></dt>
<dd><p>This function applies Ternary search</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.compute_table">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">compute_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_pred</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.compute_table" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.compute_tpr">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">compute_tpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TP</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FN</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.compute_tpr" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.compute_fpr">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">compute_fpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">FP</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">TN</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.compute_fpr" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.adjust_threshold">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">adjust_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probabilities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.adjust_threshold" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.get_scores">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">get_scores</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learner</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">folds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learner_fitted</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#mlquantify.get_scores" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.MoSS">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">MoSS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.MoSS" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.protocol_boxplot">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">protocol_boxplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">table_protocol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pandas.DataFrame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">methods</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.protocol_boxplot" title="Link to this definition"></a></dt>
<dd><p>Plots a boxplot based on the provided DataFrame and selected methods.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.protocol_lineplot">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">protocol_lineplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">table_protocol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pandas.DataFrame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">methods</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_by</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'mean'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.protocol_lineplot" title="Link to this definition"></a></dt>
<dd><p>Plots a line plot based on the provided DataFrame of the protocol and selected methods.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlquantify.class_distribution_plot">
<span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">class_distribution_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">30</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">legend</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.class_distribution_plot" title="Link to this definition"></a></dt>
<dd><p>Plot overlaid histograms of class distributions.</p>
<p>This function creates a plot with overlaid histograms, each representing the distribution
of a different class or category. Custom colors, titles, legends, and other plot parameters
can be applied to enhance visualization.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>values (Union[List, np.ndarray]):</dt><dd><p>A list of arrays or a single array containing values for specific classes or categories.</p>
</dd>
<dt>labels (Union[List, np.ndarray]):</dt><dd><p>A list or an array of labels corresponding to each value set in <cite>values</cite>.
Must be the same length as <cite>values</cite>.</p>
</dd>
<dt>bins (int, optional):</dt><dd><p>Number of bins to use in the histograms. Default is 30.</p>
</dd>
<dt>title (Optional[str], optional):</dt><dd><p>Title of the plot. If not provided, no title will be displayed.</p>
</dd>
<dt>legend (bool, optional):</dt><dd><p>Whether to display a legend. Default is True.</p>
</dd>
<dt>save_path (Optional[str], optional):</dt><dd><p>File path to save the plot image. If not provided, the plot will not be saved.</p>
</dd>
<dt>plot_params (Optional[Dict[str, Any]], optional):</dt><dd><p>Dictionary of custom plotting parameters to apply. Default is None.</p>
</dd>
</dl>
</dd>
<dt>Raises:</dt><dd><dl class="simple">
<dt>AssertionError:</dt><dd><p>If the number of labels does not match the number of value sets.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlquantify.</span></span><span class="sig-name descname"><span class="pre">GridSearchQ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="base/index.html#mlquantify.base.Quantifier" title="mlquantify.base.Quantifier"><span class="pre">mlquantify.base.Quantifier</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_grid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'app'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_prevs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_repetitions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scoring</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ae'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">refit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_split</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">42</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.GridSearchQ" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="base/index.html#mlquantify.base.Quantifier" title="mlquantify.base.Quantifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mlquantify.base.Quantifier</span></code></a></p>
<p>Hyperparameter optimization for quantification models using grid search.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>model (Quantifier): The base quantification model.
param_grid (dict): Hyperparameters to search over.
protocol (str, optional): Quantification protocol (‘app’ or ‘npp’). Defaults to ‘app’.
n_prevs (int, optional): Number of prevalence points for APP. Defaults to None.
n_repetitions (int, optional): Number of repetitions for NPP. Defaults to 1.
scoring (Union[List[str], str], optional): Metric(s) for evaluation. Defaults to “mae”.
refit (bool, optional): Refit model on best parameters. Defaults to True.
val_split (float, optional): Proportion of data for validation. Defaults to 0.4.
n_jobs (int, optional): Number of parallel jobs. Defaults to 1.
random_seed (int, optional): Seed for reproducibility. Defaults to 42.
timeout (int, optional): Max time per parameter combination (seconds). Defaults to -1.
verbose (bool, optional): Verbosity of output. Defaults to False.</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.model">
<span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#mlquantify.GridSearchQ.model" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.param_grid">
<span class="sig-name descname"><span class="pre">param_grid</span></span><a class="headerlink" href="#mlquantify.GridSearchQ.param_grid" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.protocol">
<span class="sig-name descname"><span class="pre">protocol</span></span><a class="headerlink" href="#mlquantify.GridSearchQ.protocol" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.n_prevs">
<span class="sig-name descname"><span class="pre">n_prevs</span></span><a class="headerlink" href="#mlquantify.GridSearchQ.n_prevs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.n_repetitions">
<span class="sig-name descname"><span class="pre">n_repetitions</span></span><a class="headerlink" href="#mlquantify.GridSearchQ.n_repetitions" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.refit">
<span class="sig-name descname"><span class="pre">refit</span></span><a class="headerlink" href="#mlquantify.GridSearchQ.refit" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.val_split">
<span class="sig-name descname"><span class="pre">val_split</span></span><a class="headerlink" href="#mlquantify.GridSearchQ.val_split" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.n_jobs">
<span class="sig-name descname"><span class="pre">n_jobs</span></span><a class="headerlink" href="#mlquantify.GridSearchQ.n_jobs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.random_seed">
<span class="sig-name descname"><span class="pre">random_seed</span></span><a class="headerlink" href="#mlquantify.GridSearchQ.random_seed" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.timeout">
<span class="sig-name descname"><span class="pre">timeout</span></span><a class="headerlink" href="#mlquantify.GridSearchQ.timeout" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#mlquantify.GridSearchQ.verbose" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.scoring">
<span class="sig-name descname"><span class="pre">scoring</span></span><a class="headerlink" href="#mlquantify.GridSearchQ.scoring" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.sout">
<span class="sig-name descname"><span class="pre">sout</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.GridSearchQ.sout" title="Link to this definition"></a></dt>
<dd><p>Prints messages if verbose is True.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.__get_protocol">
<span class="sig-name descname"><span class="pre">__get_protocol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.GridSearchQ.__get_protocol" title="Link to this definition"></a></dt>
<dd><p>Get the appropriate protocol instance.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>model (Quantifier): The quantification model.
sample_size (int): The sample size for batch processing.</p>
</dd>
<dt>Returns:</dt><dd><p>object: Instance of APP or NPP protocol.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.GridSearchQ.fit" title="Link to this definition"></a></dt>
<dd><p>Fit the quantifier model and perform grid search.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Training features.
y (array-like): Training labels.</p>
</dd>
<dt>Returns:</dt><dd><p>self: Fitted GridSearchQ instance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.GridSearchQ.predict" title="Link to this definition"></a></dt>
<dd><p>Make predictions using the best found model.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>X (array-like): Data to predict on.</p>
</dd>
<dt>Returns:</dt><dd><p>array-like: Predictions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.classes_">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#mlquantify.GridSearchQ.classes_" title="Link to this definition"></a></dt>
<dd><p>Get the classes of the best model.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>array-like: The classes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.set_params">
<span class="sig-name descname"><span class="pre">set_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.GridSearchQ.set_params" title="Link to this definition"></a></dt>
<dd><p>Set the hyperparameters for grid search.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>parameters (dict): Hyperparameters to set.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.get_params">
<span class="sig-name descname"><span class="pre">get_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.GridSearchQ.get_params" title="Link to this definition"></a></dt>
<dd><p>Get the parameters of the best model.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>deep (bool, optional): If True, will return the parameters for this estimator and contained subobjects. Defaults to True.</p>
</dd>
<dt>Returns:</dt><dd><p>dict: Parameters of the best model.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ.best_model">
<span class="sig-name descname"><span class="pre">best_model</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.GridSearchQ.best_model" title="Link to this definition"></a></dt>
<dd><p>Return the best model after fitting.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>Quantifier: The best model.</p>
</dd>
<dt>Raises:</dt><dd><p>ValueError: If called before fitting.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlquantify.GridSearchQ._timeout_handler">
<span class="sig-name descname"><span class="pre">_timeout_handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlquantify.GridSearchQ._timeout_handler" title="Link to this definition"></a></dt>
<dd><p>Handle timeouts during evaluation.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>signum (int): Signal number.
frame (object): Current stack frame.</p>
</dd>
<dt>Raises:</dt><dd><p>TimeoutError: When the timeout is reached.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../index.html" class="btn btn-neutral float-left" title="API Reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="base/index.html" class="btn btn-neutral float-right" title="mlquantify.base" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Luiz Fernando Luth Junior.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>